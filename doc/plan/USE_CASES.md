## Use cases
#### Lucy (Controller)
- *Start Game*: In menu page, user clicks "Start" button. MenuControl detects that button has been clicked, calls MenuControl.start() method, which calls the front end view to switch from menu view to playing field. Since a game has not been previously established, a new animation/timeline/view is created.
- *Pause Game*: During game play, user clicks "Pause" button. MainControl (?)  detects that Pause has been clicked, calls MainControl.pauseGame() method, which calls front-end-view.pause to pause the animation and front-end-view.showMenu to show menu
- *Resume Game*: In the menu page, user clicks "Start" button. MenuControl detects that button has been clicked, calls MenuControl.start() method, which calls the front end view to switch from menu view to playing field. Since a game was previously in play and paused, clicking "Start" this time would only resume the previously paused animations.
- *User presses key to go left*: Scene detects key pressed, whose event connects to MainController.keyInput. MainController.keyInput passes the argument to MainPlayerController, which passes to argument to either ZeldaPlayerControl or MarioPlayerControl depending on the type of the game. Method “left” in either player control is called, which calls backend player model’s moveInX(-1) method, moving the player left one unit. The amount moved (“-1”) can be changed through preference setting (?) 
- *User presses key to go down*: Scene detects key pressed, whose event connects to MainController.keyInput. MainController.keyInput passes the argument to MainPlayerController, which passes to argument to either ZeldaPlayerControl or MarioPlayerControl depending on the type of the game. If the game type is Mario, nothing happens as MarioPlayerControl does not implement method for "down"; if game type if Zelda, ZeldaPlayerControl calls its down() method, which in turns calls player.moveInY(-1) to move the player down one unit
- *User presses key to go Up*: Scene detects key pressed, whose event connects to MainController.keyInput. MainController.keyInput passes the argument to MainPlayerController, which passes to argument to either ZeldaPlayerControl or MarioPlayerControl depending on the type of the game. If the game type is Mario, its jump method is called, which in turns calls player.jump() method in backend to allow the player to jump; if game type if Zelda, ZeldaPlayerControl calls its up() method, which in turns calls player.moveInY(1) to move the player up one unit
- *Exit Game*: In menu, when user presses “exit” button, MenuControl detects this change and calls currentStage.close(), closing the program

#### Cady (Model)
- *Starts Game*: the main program runs and passes in a FileLoader in the constructor to Model. Model creates all necessary game elements, players and NPCs internally using information provided by the FileLoader. According to the information, Model chooses the correct type of character to create (MarioCharacter or ZeldaCharacter) using a factory.  Model waits Controller to update Model state.
- *User presses a key (for example, right arrow) to make the player character move to the right*: Controller receives the signal that user presses a key, and calls player.setState(MOVE_TO_RIGHT). In the backend, updates its state, and notify the frontend that the X position has been changed. Frontend performs this state change. 
- *Character encounters a wall*: If the frontend detects that the user encounters a wall and cannot move in that direction but the user keeps pressing the key, the frontend prevents the player from keep walking and the backend state will not be updated.
- *Player at the right edge of the current screen and wants to go right further*: the frontend detects that the player reaches the right edge of the screen and notifies the backend. The backend then checks if there is another grid on the right side of the current grid. If yes, the backend updates its grid id and notifies the frontend to update the UI. 
- *Player gets attacked: the player should implement Alive interface, which gives the player health point property*. The controller calls .subtractHP(int amount) to subtract HP from the player. Calling this method notifies the frontend, and thus updates the HP display in the frontend. 
- *Player scores points*: the player triggers an event in the frontend that should award the player points. The controller calls scrollable.addScore(int score) to add points to the player. Calling this method notifies the frontend, and thus updates the score display in the frontend.
- *Player jumps*: The player presses a key so that makes the character jump. The controller detects the key press and calls player.jump(), which changes the player’s state to jump. The backend notifies the frontend and the frontend starts animate. The backend waits a notification from the frontend to stop animation, and changes its state back to rest. 
- *Save Game*: The controller detects that the user wants to save the game and calls Model.saveGame(directory). The Model packs all its elements into unmodifiable classes (which will be created later) that only contains getters, and then calls the data management API to store them at some location. 

#### Guangyu (Data Management):
- *When starting the game, load data from the data file* : the main will call the backend, which will call the data loader to load their data. The data loader will load their data by traversing the Json file and finding the data that is in the correct file and has the correct tag.
- *Generate error when nonexisting player is requested to be loaded* : When data are loaded through dataLoader, data Loader will check the validity of the data. If the data is invalid, it will report error and throws an exception, which will be picked up by the controller and displayed to the User interface if needed.
- *Save Game Score* : Other classes will save the data by calling on the data loader, which will convert the data into a GameMapGraph and Gson will convert GameMapGraph into Json data file.
- *Save Game Life* : Other classes will save the data by calling on the data loader, which will convert the data into a GameMapGraph and Gson will convert GameMapGraph into Json data file.  
- *Save player profile* : Other classes will save the data by calling on the data loader, which will convert the data into a GameMapGraph and Gson will convert GameMapGraph into Json data file.  
- *Save user’s weapons that the player picks up on the way* : When backend want's to gives out the weapons with certain properties, it requests the property from the data file by calling methods on the DataLoaderAPI. 
- *Tell the backend the user’s key setting* : User key's setting will be stored into one of the Json file by methods on DataLoaderAPI. When the controller requests the dataFile for key's setting, it will access it through the interface of DataLoaderAPI.
- *Present different pattern on Map* : For every cell on the Grid, there is a number associated with it. That number represents the type of the grid. The frontend will generate the map based on the number on every cell.

#### Qiaoyi (Front-end):
- *Add a new item in inventor*y: After the user collects an item by making a collision between the object and the playable character and pressing the key E, the controller will notice the back-end to update the inventory status of the character and the status of the object. During the routine view update in the main game loop, the view will notice the new status of the object and update its visualization to being invisible.  
- *Player presses right and the playable agent meets the right border, then the game switches to a new map*: The main game loop in the controller detects the KeyCode event of moving rights and then calls the update method in the model. The model sets the state of the playable character to moving right. Then the listener in the front-end notices the change in the state, the view initializes the animation of moving. After noticing a border collision, it halts the animation and calls the model. Since there is a new map following the current one, the controller will update the map. Rightly after, the map listener in the view will notice and update the map and also reallocating the playable agent to its new location.
- *Player presses right and the playable agent meets the right border, then no new map is linked to it*: the main game loop in the controller detects the KeyCode event of moving rights and then calls the update method in the model. The model sets the state of the playable character to moving right. Then the listener in the front-end notices the change in the state, the view initializes the animation of moving. After noticing a border collision, it halts the animation and calls the model. Since there is no new map linking to the current one, the back-end would not update the current map. The game loop continues.
- *Player uses an animated skill to attack*: After the controller detects the user is trying to fire a skill, it would notice the back-end to change the character status to the releasing of the skill. Provided that the view has a listener to the playable agent status in the backend, the view would release the animation of the skill and it would call the model to update the state to rest. It will also judge the success of the attack based on the direction of the attack and its distance to the closest enemy. If it is a successful attack, it will notify the controller to call the model to increase the score of the player and decrease life value of the enemy.
- *Player opens the inventory of the playable character*: The controller would detect the user pressing I to open the inventory and it would update the status of the inventory panel to be visible. The inventory panel would retrieve the item list from the backend and visualize it. 
- *Player engages in a dialogue with an NPC*: After the player comes close to an NPC and presses T to talk, the controller would detect the beginning of a conversation. It would call the backend to set the dialogue status of the NPC to true, the dialogue panel in the front-end would detect it and display the dialogue. If the conversation is longer than one page, the user could press any key to continue. The controller will make checking to the model to confirm it is during a conversation period and then, if true, calls the dialogue in the front-end to scroll to a new page of conversation. When the dialogue panel finds out the conversation text is out, it would notice the backend to set the conversation status of the NPC to false. In the next round of an update, the dialogue panel would disappear.
- *Player presses pause*: When the controller detects that the player presses pause, it would switch the current game state scene to a pause scene and pause the game loop.
- *Player dies in the game*: When the life value of the player hits zero, the backend would set the state of the player to dead. The front-end would notice the status has been updated and then visualize the dying animation in the scene. After the animation rendering, it would call the backend to update the character status
